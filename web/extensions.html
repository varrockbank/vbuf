<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>buffee - Extensions</title>
  <link rel="stylesheet" href="../assets/reset.css">
</head>
<body>
  <nav id="nav"></nav>
  <script>
    fetch('navigation.html')
      .then(r => r.text())
      .then(html => document.getElementById('nav').innerHTML = html);
  </script>

  <h1>Extensions</h1>
  <p>Optional modules for buffee. Load independently.</p>

  <h2>History</h2>
  <p><a href="../extensions/history.js"><code>extensions/history.js</code></a></p>
  <p>Undo/redo support with operation coalescing. Without this extension, editors have no history.</p>
  <pre>BuffeeHistory(editor)
editor.History.undo()
editor.History.redo()
editor.History.clear()</pre>
  <p><a href="../samples/sample-history.html">Demo →</a></p>

  <h2>UndoTree</h2>
  <p><a href="../extensions/undotree.js"><code>extensions/undotree.js</code></a></p>
  <p>Tree-based undo/redo that preserves all branches. When you undo and make a new edit, you create a new branch instead of losing history.</p>
  <pre>BuffeeUndoTree(editor)
editor.UndoTree.undo()
editor.UndoTree.redo()         // Follow most recent branch
editor.UndoTree.redo(0)        // Follow specific branch
editor.UndoTree.branches()     // Get available branches
editor.UndoTree.goToNode(id)   // Jump to any node
editor.UndoTree.getTree()      // Get tree for visualization</pre>
  <p><a href="../samples/sample-undotree.html">Demo →</a></p>

  <h2>Syntax</h2>
  <p><a href="../extensions/syntax.js"><code>extensions/syntax.js</code></a></p>
  <p>Regex-based syntax highlighting with incremental state caching. Ships with JavaScript, HTML, CSS, JSON, and Python.</p>
  <pre>const editor = BuffeeSyntax(Buffee(container, config))
editor.Syntax.setLanguage('javascript')
editor.Syntax.enabled = true</pre>
  <p><a href="../samples/sample-syntax.html">Demo →</a></p>

  <h2>Elementals</h2>
  <p><a href="../extensions/elementals.js"><code>extensions/elementals.js</code></a></p>
  <p>DOM-based UI elements in a layer above text. Buttons, inputs, labels with character-unit positioning.</p>
  <pre>const editor = BuffeeElementals(Buffee(container, config))
editor.Elementals.addButton({ row: 1, col: 5, label: 'OK' })
editor.Elementals.enabled = true</pre>
  <p><a href="../samples/sample-elementals.html">Demo →</a></p>

  <h2>TUI Legacy</h2>
  <p><a href="../extensions/tui.js"><code>extensions/tui.js</code></a></p>
  <p>Terminal UI via text manipulation. Buttons, prompts, scrollboxes using box-drawing characters.</p>
  <pre>const editor = BuffeeTUI(Buffee(container, config))
editor.TUI.addButton({ row: 1, col: 2, label: 'OK', border: true })
editor.TUI.enabled = true</pre>
  <p><a href="../samples/sample-tui.html">Demo →</a></p>

  <h2>FileLoader</h2>
  <p><a href="../extensions/fileloader.js"><code>extensions/fileloader.js</code></a></p>
  <p>Multiple file loading strategies optimized for different file sizes. Choose the right loader based on your file size and memory constraints.</p>
  <pre>const editor = BuffeeFileLoader(Buffee(container, config))
await editor.FileLoader.naiveLoad(file)           // &lt;10M lines
await editor.FileLoader.chunkedBlobLoad(file)     // &lt;70M lines
await editor.FileLoader.chunkedFileReaderLoad(file)
await editor.FileLoader.streamLoad(file)
await editor.FileLoader.streamMaterializedLoad(file) // &lt;75M lines
await editor.FileLoader.streamGcHintsLoad(file)   // &lt;90M lines</pre>
  <p><a href="../samples/sample-loader.html">Demo →</a></p>

  <h2>UltraHighCapacity</h2>
  <p><a href="../extensions/ultrahighcapacity.js"><code>extensions/ultrahighcapacity.js</code></a></p>
  <p>Gzip-compressed chunked storage for massive files (1B+ lines). Decompress on scroll. Forces editor into navigation-only mode.</p>
  <pre>const editor = BuffeeUltraHighCapacity(Buffee(container, config))
editor.UltraHighCapacity.activate(50000)
await editor.UltraHighCapacity.appendLines(lines)</pre>
  <p><a href="../samples/sample-loader.html">Demo →</a></p>

  <h2>iOS</h2>
  <p><a href="../extensions/ios.js"><code>extensions/ios.js</code></a></p>
  <p>Touch interactions and on-screen keyboard input for iOS devices.</p>
  <pre>let editor = Buffee(container, config)
if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
  editor = BuffeeIOS(editor)
}
editor.iOS.focus()   // Show keyboard
editor.iOS.destroy() // Cleanup</pre>
  <p><a href="../samples/sample-ios.html">Demo →</a></p>

  <h2>StatusLine</h2>
  <p><a href="../extensions/statusline.js"><code>extensions/statusline.js</code></a></p>
  <p>Updates status bar elements (row, col, line count, spaces) on each render. Looks for elements with classes <code>.buffee-head-row</code>, <code>.buffee-head-col</code>, <code>.buffee-linecount</code>, <code>.buffee-spaces</code>.</p>
  <pre>const editor = BuffeeStatusLine(new Buffee(container, config))</pre>
  <p><a href="../samples/sample-basic.html">Demo →</a></p>

  <hr>

  <h2>Using Multiple Extensions</h2>
  <p>Compose extensions using the decorator pattern.</p>
  <pre>const editor = BuffeeElementals(
  BuffeeSyntax(
    Buffee(container, config)
  )
)

editor.Syntax.setLanguage('javascript')
editor.Syntax.enabled = true

editor.Elementals.addButton({
  row: 0, col: 40,
  label: 'Run',
  onActivate: () => console.log('Running...')
})
editor.Elementals.enabled = true</pre>

  <h3>Syntactic Sugar: reduce</h3>
  <p>For many extensions, use <code>reduce</code> to avoid deep nesting:</p>
  <pre>const extensions = [BuffeeHistory, BuffeeSyntax, BuffeeElementals]

const editor = extensions.reduce(
  (ed, ext) => ext(ed),
  new Buffee(container, config)
)</pre>

  <h3>Syntactic Sugar: pipe</h3>
  <p>A <code>pipe</code> helper reads left-to-right:</p>
  <pre>const pipe = (...fns) => x => fns.reduce((v, f) => f(v), x)

const editor = pipe(
  BuffeeHistory,
  BuffeeSyntax,
  BuffeeElementals
)(new Buffee(container, config))</pre>

</body>
</html>

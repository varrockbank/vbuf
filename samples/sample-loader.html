<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>buffee - Ultra High Capacity</title>
  <script src="../buffee.js"></script>
  <script src="../extensions/statusline.js"></script>
  <script src="../extensions/fileloader.js"></script>
  <script src="../extensions/ultrahighcapacity.js"></script>
  <link rel="stylesheet" href="../assets/reset.css">
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../themes/theme-eva.css">
  <link rel="stylesheet" href="../themes/theme-boring.css">
  <style>
    fieldset { margin: 16px 0; padding: 12px; }
    .hidden { display: none; }
    #file-loader-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #file-loader-options button {
      margin: 0;
      text-align: left;
    }
    .read-only-indicator {
      background-color: #ff6b35;
      color: white;
      padding: 8px 16px;
      text-align: center;
      font-weight: 500;
      font-size: 14px;
      margin: 0 0 -1px 0;
      border: 1px solid #ff6b35;
    }
  </style>
</head>
<body class="sample">
  <nav id="nav"></nav>
  <script>
    fetch('../web/navigation.html')
      .then(r => r.text())
      .then(html => document.getElementById('nav').innerHTML = html);
  </script>
  <p><a href="../index.html">home</a> / <a href="index.html">samples</a> / Ultra High Capacity</p>

  <h1>Ultra High Capacity</h1>
  <p>Load and display files with millions or billions of lines using various loading strategies.</p>

  <div id="read-only-indicator" class="read-only-indicator hidden">
    Read-Only Mode (Chunked+Compressed) - Navigation only, editing disabled
  </div>
  <div class="buffee buffee-themepack1-eva" id="editor">
    <textarea class="buffee-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="no-select buffee-elements">
      <div class="buffee-gutter"></div>
      <div class="buffee-lines" tabindex="0">
        <div class="buffee-layer-selection"></div>
        <blockquote class="buffee-layer-text"></blockquote>
        <div class="buffee-layer-elements"></div>
        <div class="buffee-cursor"></div>
      </div>
    </div>
    <div class="buffee-status">
      <div class="buffee-status-left"><span class="buffee-linecount"></span></div>
      <div class="buffee-status-right">
        Ln <span class="buffee-head-row"></span>, Col <span class="buffee-head-col"></span>
        <span class="buffee-status-divider">|</span>
        <span class="buffee-spaces"></span>
      </div>
    </div>
  </div>

  <fieldset>
    <legend>Viewport:</legend>
    <label for="viewport-start">Start:</label>
    <input id="viewport-start" value="1">
    <label for="viewport-size">Window size:</label>
    <input id="viewport-size" value="15">
    <button id="viewport-update">Set</button>
  </fieldset>

  <fieldset>
    <legend>File Loader:</legend>
    <div>
      <label for="file-input"><span id="fileSize"></span></label>
      <input id="file-input" type="file" name="myFiles" style="width: 100%; box-sizing: border-box;">

      <div id="file-loader-buttons" style="margin-top: 16px;">
        <div style="margin-bottom: 12px;">
          <label for="append-at-line">Insert at line: </label><input id="append-at-line" value="1">
        </div>
        <div style="margin-bottom: 12px;">
          <strong>Choose loading strategy:</strong>
        </div>
        <div id="file-loader-options">
          <button id="load-file-naive">Standard Loader <code style="margin-left: 8px;">&lt;10M lines</code></button>
          <button id="load-file-chunked">Chunked (File.slice) <code style="margin-left: 8px;">&lt;70M lines</code></button>
          <button id="load-file-filereader">Chunked (FileReader) <code style="margin-left: 8px;">&lt;70M lines</code></button>
          <button id="load-file-stream">Streaming (ReadableStream) <code style="margin-left: 8px;">&lt;70M lines</code></button>
          <button id="load-file-stream-materialized">Streaming + Materialization <code style="margin-left: 8px;">&lt;75M lines</code></button>
          <button id="load-file-stream-materialized-gc">Streaming + GC Hints <code style="margin-left: 8px;">&lt;90M lines</code></button>
          <button id="load-file-chunked-compressed">Ultra-High-Capacity Mode <code style="margin-left: 8px;">1B+ lines (read-only)</code></button>
        </div>
      </div>
    </div>
  </fieldset>

  <fieldset>
    <legend>Progress Bar Demo:</legend>
    <p>The progress bar API is decoupled from file loading - useful for server-driven progress.</p>
    <button id="demo-progress">Simulate Server Load (3s)</button>
  </fieldset>

  <h3>Logs:</h3>
  <div class="buffee buffee-themepack1-boring" id="logs-editor">
    <textarea class="buffee-clipboard-bridge" aria-hidden="true"></textarea>
    <div class="no-select buffee-elements">
      <div class="buffee-gutter"></div>
      <div class="buffee-lines" tabindex="0">
        <div class="buffee-layer-selection"></div>
        <blockquote class="buffee-layer-text"></blockquote>
        <div class="buffee-layer-elements"></div>
        <div class="buffee-cursor"></div>
      </div>
    </div>
    <div class="buffee-status">
      <div class="buffee-status-left"><span class="buffee-linecount"></span></div>
      <div class="buffee-status-right">
        Ln <span class="buffee-head-row"></span>, Col <span class="buffee-head-col"></span>
        <span class="buffee-status-divider">|</span>
        <span class="buffee-spaces"></span>
      </div>
    </div>
  </div>

  <script>
    const editorEl = document.getElementById('editor');
    const logsEl = document.getElementById('logs-editor');

    const logs = BuffeeStatusLine(new Buffee(logsEl, { rows: 8 }));

    function log(s) {
      console.log(s);
      // Append line and scroll to show it
      if (logs.Model.lines[0] === '') {
        logs.Model.lines[0] = s;
      } else {
        logs.Model.lines.push(s);
      }
      logs.Viewport.start = Math.max(0, logs.Model.lines.length - logs.Viewport.size - 1);
      logs._render(true);
    }

    const editor = BuffeeUltraHighCapacity(BuffeeFileLoader(BuffeeStatusLine(
      new Buffee(editorEl, { rows: 10, logger: log })
    )));

    editor.Model.text = 'Select a file to load...';
    editorEl.focus();

    // Viewport controls
    document.getElementById('viewport-update').addEventListener('click', () => {
      const viewportStart = parseInt(document.getElementById('viewport-start').value);
      const viewportSize = parseInt(document.getElementById('viewport-size').value);
      editor.Viewport.set(viewportStart, viewportSize);
    });

    // File input handler
    document.getElementById("file-input").addEventListener("change", () => {
      const file = document.getElementById("file-input").files[0];
      const nBytes = file.size;
      const aMultiples = ["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
      let sOutput = "";
      for (nMultiple = 0, nApprox = nBytes / 1024; nApprox > 1; nApprox /= 1024, nMultiple++) {
        sOutput = nApprox.toFixed(3) + " " + aMultiples[nMultiple] + " (" + nBytes + " bytes)";
      }
      document.getElementById("fileSize").innerHTML = "File size: " + (sOutput || (nBytes + " bytes"));
      document.getElementById("file-loader-buttons").classList.remove('hidden');
    }, false);

    // Progress callback for all loaders
    const onProgress = (p) => editor.FileLoader.setProgress(p);

    // Standard Loader
    document.getElementById('load-file-naive').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) { alert("No file selected"); return; }

      editor.FileLoader.showProgress();
      const result = await editor.FileLoader.naiveLoad(f);
      editor.FileLoader.hideProgress();
      const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
      log(`[Naive] Loaded ${result.lines.toLocaleString()} lines in ${result.timeMs.toFixed(2)}ms // ${fileSizeMiB} MiB`);
    });

    // Chunked (File.slice)
    document.getElementById('load-file-chunked').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) { alert("No file selected"); return; }

      editor.FileLoader.showProgress();
      const result = await editor.FileLoader.chunkedBlobLoad(f, { onProgress });
      editor.FileLoader.hideProgress();
      const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
      log(`[Chunked] Loaded ${result.lines.toLocaleString()} lines in ${result.timeMs.toFixed(2)}ms // ${fileSizeMiB} MiB`);
    });

    // Chunked (FileReader)
    document.getElementById('load-file-filereader').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) { alert("No file selected"); return; }

      editor.FileLoader.showProgress();
      const result = await editor.FileLoader.chunkedFileReaderLoad(f, { onProgress });
      editor.FileLoader.hideProgress();
      const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
      log(`[FileReader] Loaded ${result.lines.toLocaleString()} lines in ${result.timeMs.toFixed(2)}ms // ${fileSizeMiB} MiB`);
    });

    // Streaming (ReadableStream)
    document.getElementById('load-file-stream').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) { alert("No file selected"); return; }

      editor.FileLoader.showProgress();
      const result = await editor.FileLoader.streamLoad(f, { onProgress });
      editor.FileLoader.hideProgress();
      const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
      log(`[Stream] Loaded ${result.lines.toLocaleString()} lines in ${result.timeMs.toFixed(2)}ms // ${fileSizeMiB} MiB`);
    });

    // Streaming + Materialization
    document.getElementById('load-file-stream-materialized').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) { alert("No file selected"); return; }

      editor.FileLoader.showProgress();
      const result = await editor.FileLoader.streamMaterializedLoad(f, { onProgress });
      editor.FileLoader.hideProgress();
      const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
      log(`[Stream+Mat] Loaded ${result.lines.toLocaleString()} lines in ${result.timeMs.toFixed(2)}ms // ${fileSizeMiB} MiB`);
    });

    // Streaming + GC Hints
    document.getElementById('load-file-stream-materialized-gc').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) { alert("No file selected"); return; }

      editor.FileLoader.showProgress();
      const result = await editor.FileLoader.streamGcHintsLoad(f, { onProgress });
      editor.FileLoader.hideProgress();
      const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
      log(`[Stream+GC] Loaded ${result.lines.toLocaleString()} lines in ${result.timeMs.toFixed(2)}ms // ${fileSizeMiB} MiB`);
    });

    // Ultra-High-Capacity Mode (Chunked + Compressed)
    document.getElementById('load-file-chunked-compressed').addEventListener('click', async () => {
      const f = document.getElementById("file-input").files[0];
      if (!f) { alert("No file selected"); return; }

      editor.FileLoader.showProgress();
      const reader = f.stream().getReader();
      try {
        editor.UltraHighCapacity.activate();
        document.getElementById('read-only-indicator').classList.remove('hidden');

        const decoder = new TextDecoder('utf-8');
        let chunkCount = 0;
        let bytesRead = 0;
        const t0 = performance.now();
        let remainder = '';
        let originalSize = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          bytesRead += value.length;
          const text = decoder.decode(value, { stream: true });
          const lastNewlineIndex = text.lastIndexOf('\n');

          if (lastNewlineIndex !== -1) {
            const allLines = text.split('\n');
            const slicedLines = allLines.slice(0, -1);
            slicedLines[0] = remainder + slicedLines[0];
            remainder = allLines[allLines.length - 1];

            const materializedLines = slicedLines.map(line => Array.from(line).join(''));
            originalSize += materializedLines.join('\n').length;
            await editor._.appendLines(materializedLines, true);
          } else {
            remainder += text;
          }

          chunkCount++;
          if (chunkCount % 10 === 0) {
            editor.FileLoader.setProgress(bytesRead / f.size);
            await editor._.appendLines([], false);
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }

        if (remainder.length > 0) {
          await editor._.appendLines([remainder], false);
        }

        editor.FileLoader.hideProgress();
        const compressedSize = editor.UltraHighCapacity.compressedSize;
        const t1 = performance.now();
        const fileSizeMiB = (f.size / (1024 * 1024)).toFixed(3);
        const compressionRatio = ((1 - compressedSize / originalSize) * 100).toFixed(1);

        log(`[Chunked+Compressed] Stored ${editor.UltraHighCapacity.totalLines.toLocaleString()} lines in ${editor.UltraHighCapacity.chunkCount} gzipped chunks`);
        log(`  Time: ${(t1 - t0).toFixed(2)}ms // File: ${fileSizeMiB} MiB (${f.size} bytes)`);
        log(`  Original size: ${(originalSize / 1024 / 1024).toFixed(2)} MiB`);
        log(`  Compressed size: ${(compressedSize / 1024 / 1024).toFixed(2)} MiB`);
        log(`  Compression ratio: ${compressionRatio}% savings`);
        log(`  Memory savings: ${editor.UltraHighCapacity.chunkCount} chunks vs ${editor.UltraHighCapacity.totalLines.toLocaleString()} array elements = ${(editor.UltraHighCapacity.totalLines / editor.UltraHighCapacity.chunkCount).toFixed(0)}x reduction`);
      } finally {
        reader.releaseLock();
      }
    });

    // Progress bar demo (simulates server-driven progress)
    document.getElementById('demo-progress').addEventListener('click', async () => {
      editor.FileLoader.showProgress();
      log('[Progress Demo] Starting simulated server load...');

      for (let i = 0; i <= 100; i += 5) {
        editor.FileLoader.setProgress(i / 100);
        await new Promise(r => setTimeout(r, 150));
      }

      editor.FileLoader.hideProgress();
      log('[Progress Demo] Complete');
    });
  </script>
</body>
</html>
